diff --git a/kernel/ksud.c b/kernel/ksud.c
index d671193d..d083246e 100644
--- a/kernel/ksud.c
+++ b/kernel/ksud.c
@@ -16,6 +16,15 @@
 #include <linux/uaccess.h>
 #include <linux/namei.h>
 #include <linux/workqueue.h>
+#ifdef CONFIG_TRACEPOINTS
+#include <linux/tracepoint.h>
+#include <trace/events/sched.h>
+#include <linux/module.h>
+#endif // CONFIG_TRACEPOINTS
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/atomic.h>
+#include <linux/rcupdate.h>
 
 #include "manager.h"
 #include "allowlist.h"
@@ -26,6 +35,73 @@
 #include "selinux/selinux.h"
 #include "throne_tracker.h"
 
+#ifdef CONFIG_TRACEPOINTS
+// one-shot (atomic (avoids race(s) across CPUs))
+static atomic_t ksud_root_done = ATOMIC_INIT(0);
+
+// callback_head (static; lifetime for task_work_add)
+static struct callback_head ksud_cb = { .func = NULL };
+
+// task_work callback (root grant after staged boot)
+static void ksud_post_fs_data_cb(struct callback_head *cb)
+{
+	on_post_fs_data();
+}
+
+// exec callback (tracepoint)
+static void ksud_exec_trace(void *ignore,
+			    struct task_struct *p,
+			    pid_t old_pid,
+			    struct linux_binprm *bprm)
+{
+	struct task_struct *init_task;
+
+	// validate
+	if (!bprm || !bprm->filename)
+		return;
+
+	// trigger (first app_process / zygote)
+	const char *base = strrchr(bprm->filename, '/');
+	base = base ? base + 1 : bprm->filename;
+	if (!strcmp(base, "app_process") || !strcmp(base, "app_process64") ||
+		!strcmp(base, "zygote") || !strcmp(base, "zygote64")) {
+
+		// one-shot claim (exit if another (CPU) did)
+		if (atomic_cmpxchg(&ksud_root_done, 0, 1) != 0)
+			return;
+
+		pr_info("KernelSU: trace exec %s pid=%d (schedule)\n",
+				bprm->filename, p->pid);
+
+		rcu_read_lock();
+		init_task = rcu_dereference(p->real_parent);
+		if (init_task) {
+			ksud_cb.func = ksud_post_fs_data_cb;
+			task_work_add(init_task, &ksud_cb, TWA_RESUME);
+		}
+		rcu_read_unlock();
+	}
+}
+
+// register (late init (tracepoint)) / cleanup (module exit)
+static int __init ksud_tracepoint_init(void)
+{
+	register_trace_sched_process_exec(ksud_exec_trace, NULL);
+	return 0;
+}
+
+// unregister; synchro. rcu (in-flight)
+static void __exit ksud_tracepoint_exit(void)
+{
+	unregister_trace_sched_process_exec(ksud_exec_trace, NULL);
+	synchronize_rcu();
+}
+
+// Note: built-in stays registered (Android didn't like it)
+late_initcall(ksud_tracepoint_init);
+module_exit(ksud_tracepoint_exit);
+#endif // CONFIG_TRACEPOINTS
+
 bool ksu_module_mounted __read_mostly = false;
 bool ksu_boot_completed __read_mostly = false;
 
@@ -46,10 +46,9 @@ static const char KERNEL_SU_RC[] =
 	"    exec u:r:" KERNEL_SU_DOMAIN ":s0 root -- " KSUD_PATH " services\n"
 	"\n"
 
-    "on property:sys.boot_completed=1\n"
-    "    exec u:r:" KERNEL_SU_DOMAIN ":s0 root -- " KSUD_PATH
-    " boot-completed\n"
-    "\n"
+	"on property:sys.boot_completed=1\n"
+	"    exec u:r:" KERNEL_SU_DOMAIN ":s0 root -- " KSUD_PATH " boot-completed\n"
+	"\n"
 
 	"\n";
 
@@ -228,6 +227,14 @@ int ksu_handle_execveat_ksud(int *fd, struct filename **filename_ptr,
 		return 0;
 	}
 
+#ifdef CONFIG_KSU_SUSFS
+    if (!ksu_handle_execveat_init(filename)) {
+        // - return non-zero here if ksu_handle_execveat_init() return success
+        //   as we don't want it to execute ksu_handle_execveat_sucompat()
+        return 1;
+    }
+#endif // #ifdef CONFIG_KSU_SUSFS
+
 	// https://cs.android.com/android/platform/superproject/+/android-16.0.0_r2:system/core/init/main.cpp;l=77
 	if (unlikely(!memcmp(filename->name, system_bin_init,
 				sizeof(system_bin_init) - 1) &&
@@ -304,6 +311,11 @@ static ssize_t read_iter_proxy(struct kiocb *iocb, struct iov_iter *to)
 static int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
 				size_t *count_ptr, loff_t **pos)
 {
+#ifdef CONFIG_KSU_SUSFS
+    if (!ksu_vfs_read_hook) {
+        return 0;
+    }
+#endif // #ifdef CONFIG_KSU_SUSFS
 	struct file *file;
 	char __user *buf;
 	size_t count;
@@ -389,9 +401,13 @@ static int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
 
 	return 0;
 }
-
+#ifndef CONFIG_KSU_SUSFS
 static int ksu_handle_sys_read(unsigned int fd, char __user **buf_ptr,
 				size_t *count_ptr)
+#else
+int ksu_handle_sys_read(unsigned int fd, char __user **buf_ptr,
+                               size_t *count_ptr)
+#endif // #ifndef CONFIG_KSU_SUSFS
 {
 	struct file *file = fget(fd);
 	if (!file) {
@@ -412,6 +428,11 @@ static bool is_volumedown_enough(unsigned int count)
 int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code,
 					int *value)
 {
+#ifdef CONFIG_KSU_SUSFS
+    if (!ksu_input_hook) {
+        return 0;
+    }
+#endif // #ifdef CONFIG_KSU_SUSFS
 	if (*type == EV_KEY && *code == KEY_VOLUMEDOWN) {
 		int val = *value;
 		pr_info("KEY_VOLUMEDOWN val: %d\n", val);
@@ -532,17 +553,27 @@ static void do_stop_input_hook(struct work_struct *work)
 {
 	unregister_kprobe(&input_event_kp);
 }
-
+#endif // #ifndef CONFIG_KSU_SUSFS
 static void stop_vfs_read_hook()
 {
+#ifndef CONFIG_KSU_SUSFS
 	bool ret = schedule_work(&stop_vfs_read_work);
 	pr_info("unregister vfs_read kprobe: %d!\n", ret);
+#else
+    ksu_vfs_read_hook = false;
+    pr_info("stop vfs_read_hook\n");
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
 
 static void stop_execve_hook()
 {
+#ifndef CONFIG_KSU_SUSFS
 	bool ret = schedule_work(&stop_execve_hook_work);
 	pr_info("unregister execve kprobe: %d!\n", ret);
+#else
+    ksu_execveat_hook = false;
+    pr_info("stop execve_hook\n");
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
 
 static void stop_input_hook()
@@ -552,13 +583,19 @@ static void stop_input_hook()
 		return;
 	}
 	input_hook_stopped = true;
+#ifndef CONFIG_KSU_SUSFS
 	bool ret = schedule_work(&stop_input_hook_work);
 	pr_info("unregister input kprobe: %d!\n", ret);
+#else
+    ksu_input_hook = false;
+    pr_info("stop input_hook\n");
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
 
 // ksud: module support
 void ksu_ksud_init()
 {
+#ifndef CONFIG_KSU_SUSFS
 	int ret;
 
 	ret = register_kprobe(&execve_kp);
@@ -573,12 +610,15 @@ void ksu_ksud_init()
 	INIT_WORK(&stop_vfs_read_work, do_stop_vfs_read_hook);
 	INIT_WORK(&stop_execve_hook_work, do_stop_execve_hook);
 	INIT_WORK(&stop_input_hook_work, do_stop_input_hook);
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
 
 void ksu_ksud_exit()
 {
+#ifndef CONFIG_KSU_SUSFS
 	unregister_kprobe(&execve_kp);
 	// this should be done before unregister vfs_read_kp
 	// unregister_kprobe(&vfs_read_kp);
 	unregister_kprobe(&input_event_kp);
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
\ No newline at end of file
